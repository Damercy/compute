---
layout: post
title: The different domains of CS and transitioning
date: 2020-05-28 12:58:00 +0530
permalink: /:title
---
Sorry for the late post. I've been a bit busy and unwell the past couple of months.

I want to let you know about the different domains of Computer Science and a thought on transitioning. Be warned, these are not official domains of CS, but more like what I hear from my peers and everyone else. I am sure you must've heard about them before.

---
## Domains of CS
1. Web development 
2. App development
3. Machine Learning
4. Software Engineer

The above 4 domains broadly classify the choices a computer science engineer graduate has, at least in my head. A person has to choose any one of the above options and stick with it long enough to get a above-average grasp of the domain and hopefully land a job.

Now here's some thoughts on my part on each of the 4 domains.  
### 1. Web Development
---
A web developer mainly builds the webpages. Frontend developers focus on building UI, backend developers on routing and events while fullstack developers do all of it.

Currently, a fullstack developer is preferred because of their ability to build a web project from scratch.

I like aesthetics.. I mean who doesn't? Consequently, I like the frontend aspect of web development. But then, I also like problems and puzzles... a job of the backend, I suppose? So I think I would like backend as well.

The only way to find out is ___to try___. Coming back on this later.

### 2. App Development
---
An app developer builds mobile applciations, ios/android ecosystem based on their skillset. I suppose there's no frontend and backend in this domain as an app developer handles all of it.. much like a fullstack web developer.

But there are distinctions between type of app developer based on languages and frameworks, OS etc.

Currently, cross platform developers are on the rise as this means an app developer can code in a single language and produce apps for different platforms aka android,ios,web etc. through a single codebase. In terms of business perspective, it reduces operation cost as few app developers are required.

Now, I also like building mobile applications and that's mostly because:
*  I get to use different sensors and hardware of the device. So I can get creative with my application on a hardware level.

* Majority of the users are on the mobile. I'm pretty sure that even you are reading this blog post on a mobile device, aren't you?

And most users that are spending their time on mobile spend it mostly on entertainment as shown in the below infographic.

![](/compute/images/data-mobile.png "Statistics of mobile time spent")

As of writing this post, I have a good chance of landing an internship at a company as an app developer. So there's my chance to experience app development in real life. Let's see how I like it!

### 3. Machine Learning
---
ML is actually a technology, a field, by definiton and not a domain but let's not go into the technical details. By Machine Learning, I mean those people who integrate and build ML models. These models form the basis of many business logic.

Currently, ML engineers are highly sought after because every company out there wants to flaunt out the `"AI"` tag. That they have intelligent systems and so you should trust them.



You shouldn't.

ML is still in it's nascent stage and an application that uses AI is far from being really practical as of now. But that doesn't hide the fact that ML engineers are paid the most among all the 4 domains of CS.

Personally, I don't like ML as evident from the tone of this section I suppose.  Because in my head, it's still in development and we cannot really build practical applications with it, except if you're working in Google or a large corporation with huge funding.

>I mean those guys probably write C++ codes to build tensorflow cores like wtf...

### 4. Software Engineer
---
This is a very blurry domain in my opinion. Now up until a couple of months back I believed that a software engineer is a programmer who writes hardcore logic and code, builds system applications, manages database and OS functionalities aka very hardcore cool stuff.

Little did I know that all the above 3 domains (Web dev. - App dev. - ML Engg.) are also known as software engineers. I mean yes, if you ask a person with a non-CS background, to him/her there's no distinct boundary in the above 4 domains ------ all of them are software engineers to him/her.

But in my head lied this distinction. And it hurt a little, not gonna lie.

I like to see myself building hardcore logic and stuff, but that would take much time for a person of my caliber (caliber: very low) and so I think I need to look at the other domains for now.

I did competitive programming with the hope that I am increasing my knowledge of puzzles and thereby incrementing my caliber one step at a time.. That one day I might as well find myself programming a system application at a company. But I need to understand that software development is much more than simply coding.

That the UI matters, testing is crucial and that it's mostly about `making profit`.

Trasitioning refers to the term of changing from one domain to another.

Althought I haven't yet started my journey into the real world as a developer, I will (hopefully) by next year and so before I put in all my efforts and my mind in a project that I will love, I want to make sure that it's the right one.

And the only way to find out is to keep on transitioning and explore all the options while there's still time. 

So during these times of corona, I will be trying my hands on web development and build some simple applications.

To start with, I want to build a nice website for my friend, Anurag Kumar, the birthday of whom is approaching. The website will be a simple birthday wishing website using Javascript/HTML/CSS. 

Wish me luck and thanks for making it till here!

__P.S.__ This infographic pretty much shows the _real_ domains of Computer Science ( albeit it's still incomplete ), in case you were curious. Cheers!

---


![](/compute/images/domains.png "Domains of CS")